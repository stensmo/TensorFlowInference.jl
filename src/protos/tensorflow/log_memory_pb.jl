# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:44.028

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export MemoryLogTensorOutput, MemoryLogTensorAllocation, MemoryLogStep
export MemoryLogTensorDeallocation, MemoryLogRawAllocation, MemoryLogRawDeallocation

struct MemoryLogTensorOutput
    step_id::Int64
    kernel_name::String
    index::Int32
    tensor::Union{Nothing,TensorDescription}
end
PB.default_values(::Type{MemoryLogTensorOutput}) = (;step_id = zero(Int64), kernel_name = "", index = zero(Int32), tensor = nothing)
PB.field_numbers(::Type{MemoryLogTensorOutput}) = (;step_id = 1, kernel_name = 2, index = 3, tensor = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MemoryLogTensorOutput})
    step_id = zero(Int64)
    kernel_name = ""
    index = zero(Int32)
    tensor = Ref{Union{Nothing,TensorDescription}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            step_id = PB.decode(d, Int64)
        elseif field_number == 2
            kernel_name = PB.decode(d, String)
        elseif field_number == 3
            index = PB.decode(d, Int32)
        elseif field_number == 4
            PB.decode!(d, tensor)
        else
            PB.skip(d, wire_type)
        end
    end
    return MemoryLogTensorOutput(step_id, kernel_name, index, tensor[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MemoryLogTensorOutput)
    initpos = position(e.io)
    x.step_id != zero(Int64) && PB.encode(e, 1, x.step_id)
    !isempty(x.kernel_name) && PB.encode(e, 2, x.kernel_name)
    x.index != zero(Int32) && PB.encode(e, 3, x.index)
    !isnothing(x.tensor) && PB.encode(e, 4, x.tensor)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MemoryLogTensorOutput)
    encoded_size = 0
    x.step_id != zero(Int64) && (encoded_size += PB._encoded_size(x.step_id, 1))
    !isempty(x.kernel_name) && (encoded_size += PB._encoded_size(x.kernel_name, 2))
    x.index != zero(Int32) && (encoded_size += PB._encoded_size(x.index, 3))
    !isnothing(x.tensor) && (encoded_size += PB._encoded_size(x.tensor, 4))
    return encoded_size
end

struct MemoryLogTensorAllocation
    step_id::Int64
    kernel_name::String
    tensor::Union{Nothing,TensorDescription}
end
PB.default_values(::Type{MemoryLogTensorAllocation}) = (;step_id = zero(Int64), kernel_name = "", tensor = nothing)
PB.field_numbers(::Type{MemoryLogTensorAllocation}) = (;step_id = 1, kernel_name = 2, tensor = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MemoryLogTensorAllocation})
    step_id = zero(Int64)
    kernel_name = ""
    tensor = Ref{Union{Nothing,TensorDescription}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            step_id = PB.decode(d, Int64)
        elseif field_number == 2
            kernel_name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, tensor)
        else
            PB.skip(d, wire_type)
        end
    end
    return MemoryLogTensorAllocation(step_id, kernel_name, tensor[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MemoryLogTensorAllocation)
    initpos = position(e.io)
    x.step_id != zero(Int64) && PB.encode(e, 1, x.step_id)
    !isempty(x.kernel_name) && PB.encode(e, 2, x.kernel_name)
    !isnothing(x.tensor) && PB.encode(e, 3, x.tensor)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MemoryLogTensorAllocation)
    encoded_size = 0
    x.step_id != zero(Int64) && (encoded_size += PB._encoded_size(x.step_id, 1))
    !isempty(x.kernel_name) && (encoded_size += PB._encoded_size(x.kernel_name, 2))
    !isnothing(x.tensor) && (encoded_size += PB._encoded_size(x.tensor, 3))
    return encoded_size
end

struct MemoryLogStep
    step_id::Int64
    handle::String
end
PB.default_values(::Type{MemoryLogStep}) = (;step_id = zero(Int64), handle = "")
PB.field_numbers(::Type{MemoryLogStep}) = (;step_id = 1, handle = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MemoryLogStep})
    step_id = zero(Int64)
    handle = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            step_id = PB.decode(d, Int64)
        elseif field_number == 2
            handle = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return MemoryLogStep(step_id, handle)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MemoryLogStep)
    initpos = position(e.io)
    x.step_id != zero(Int64) && PB.encode(e, 1, x.step_id)
    !isempty(x.handle) && PB.encode(e, 2, x.handle)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MemoryLogStep)
    encoded_size = 0
    x.step_id != zero(Int64) && (encoded_size += PB._encoded_size(x.step_id, 1))
    !isempty(x.handle) && (encoded_size += PB._encoded_size(x.handle, 2))
    return encoded_size
end

struct MemoryLogTensorDeallocation
    allocation_id::Int64
    allocator_name::String
end
PB.default_values(::Type{MemoryLogTensorDeallocation}) = (;allocation_id = zero(Int64), allocator_name = "")
PB.field_numbers(::Type{MemoryLogTensorDeallocation}) = (;allocation_id = 1, allocator_name = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MemoryLogTensorDeallocation})
    allocation_id = zero(Int64)
    allocator_name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            allocation_id = PB.decode(d, Int64)
        elseif field_number == 2
            allocator_name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return MemoryLogTensorDeallocation(allocation_id, allocator_name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MemoryLogTensorDeallocation)
    initpos = position(e.io)
    x.allocation_id != zero(Int64) && PB.encode(e, 1, x.allocation_id)
    !isempty(x.allocator_name) && PB.encode(e, 2, x.allocator_name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MemoryLogTensorDeallocation)
    encoded_size = 0
    x.allocation_id != zero(Int64) && (encoded_size += PB._encoded_size(x.allocation_id, 1))
    !isempty(x.allocator_name) && (encoded_size += PB._encoded_size(x.allocator_name, 2))
    return encoded_size
end

struct MemoryLogRawAllocation
    step_id::Int64
    operation::String
    num_bytes::Int64
    ptr::UInt64
    allocation_id::Int64
    allocator_name::String
end
PB.default_values(::Type{MemoryLogRawAllocation}) = (;step_id = zero(Int64), operation = "", num_bytes = zero(Int64), ptr = zero(UInt64), allocation_id = zero(Int64), allocator_name = "")
PB.field_numbers(::Type{MemoryLogRawAllocation}) = (;step_id = 1, operation = 2, num_bytes = 3, ptr = 4, allocation_id = 5, allocator_name = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MemoryLogRawAllocation})
    step_id = zero(Int64)
    operation = ""
    num_bytes = zero(Int64)
    ptr = zero(UInt64)
    allocation_id = zero(Int64)
    allocator_name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            step_id = PB.decode(d, Int64)
        elseif field_number == 2
            operation = PB.decode(d, String)
        elseif field_number == 3
            num_bytes = PB.decode(d, Int64)
        elseif field_number == 4
            ptr = PB.decode(d, UInt64)
        elseif field_number == 5
            allocation_id = PB.decode(d, Int64)
        elseif field_number == 6
            allocator_name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return MemoryLogRawAllocation(step_id, operation, num_bytes, ptr, allocation_id, allocator_name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MemoryLogRawAllocation)
    initpos = position(e.io)
    x.step_id != zero(Int64) && PB.encode(e, 1, x.step_id)
    !isempty(x.operation) && PB.encode(e, 2, x.operation)
    x.num_bytes != zero(Int64) && PB.encode(e, 3, x.num_bytes)
    x.ptr != zero(UInt64) && PB.encode(e, 4, x.ptr)
    x.allocation_id != zero(Int64) && PB.encode(e, 5, x.allocation_id)
    !isempty(x.allocator_name) && PB.encode(e, 6, x.allocator_name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MemoryLogRawAllocation)
    encoded_size = 0
    x.step_id != zero(Int64) && (encoded_size += PB._encoded_size(x.step_id, 1))
    !isempty(x.operation) && (encoded_size += PB._encoded_size(x.operation, 2))
    x.num_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.num_bytes, 3))
    x.ptr != zero(UInt64) && (encoded_size += PB._encoded_size(x.ptr, 4))
    x.allocation_id != zero(Int64) && (encoded_size += PB._encoded_size(x.allocation_id, 5))
    !isempty(x.allocator_name) && (encoded_size += PB._encoded_size(x.allocator_name, 6))
    return encoded_size
end

struct MemoryLogRawDeallocation
    step_id::Int64
    operation::String
    allocation_id::Int64
    allocator_name::String
    deferred::Bool
end
PB.default_values(::Type{MemoryLogRawDeallocation}) = (;step_id = zero(Int64), operation = "", allocation_id = zero(Int64), allocator_name = "", deferred = false)
PB.field_numbers(::Type{MemoryLogRawDeallocation}) = (;step_id = 1, operation = 2, allocation_id = 3, allocator_name = 4, deferred = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MemoryLogRawDeallocation})
    step_id = zero(Int64)
    operation = ""
    allocation_id = zero(Int64)
    allocator_name = ""
    deferred = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            step_id = PB.decode(d, Int64)
        elseif field_number == 2
            operation = PB.decode(d, String)
        elseif field_number == 3
            allocation_id = PB.decode(d, Int64)
        elseif field_number == 4
            allocator_name = PB.decode(d, String)
        elseif field_number == 5
            deferred = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return MemoryLogRawDeallocation(step_id, operation, allocation_id, allocator_name, deferred)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MemoryLogRawDeallocation)
    initpos = position(e.io)
    x.step_id != zero(Int64) && PB.encode(e, 1, x.step_id)
    !isempty(x.operation) && PB.encode(e, 2, x.operation)
    x.allocation_id != zero(Int64) && PB.encode(e, 3, x.allocation_id)
    !isempty(x.allocator_name) && PB.encode(e, 4, x.allocator_name)
    x.deferred != false && PB.encode(e, 5, x.deferred)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MemoryLogRawDeallocation)
    encoded_size = 0
    x.step_id != zero(Int64) && (encoded_size += PB._encoded_size(x.step_id, 1))
    !isempty(x.operation) && (encoded_size += PB._encoded_size(x.operation, 2))
    x.allocation_id != zero(Int64) && (encoded_size += PB._encoded_size(x.allocation_id, 3))
    !isempty(x.allocator_name) && (encoded_size += PB._encoded_size(x.allocator_name, 4))
    x.deferred != false && (encoded_size += PB._encoded_size(x.deferred, 5))
    return encoded_size
end
