# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:44.044

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"GraphDebugInfo.FileLineCol", var"GraphDebugInfo.StackTrace", GraphDebugInfo

struct var"GraphDebugInfo.FileLineCol"
    file_index::Int32
    line::Int32
    col::Int32
    func::String
    code::String
end
PB.default_values(::Type{var"GraphDebugInfo.FileLineCol"}) = (;file_index = zero(Int32), line = zero(Int32), col = zero(Int32), func = "", code = "")
PB.field_numbers(::Type{var"GraphDebugInfo.FileLineCol"}) = (;file_index = 1, line = 2, col = 3, func = 4, code = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"GraphDebugInfo.FileLineCol"})
    file_index = zero(Int32)
    line = zero(Int32)
    col = zero(Int32)
    func = ""
    code = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            file_index = PB.decode(d, Int32)
        elseif field_number == 2
            line = PB.decode(d, Int32)
        elseif field_number == 3
            col = PB.decode(d, Int32)
        elseif field_number == 4
            func = PB.decode(d, String)
        elseif field_number == 5
            code = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"GraphDebugInfo.FileLineCol"(file_index, line, col, func, code)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"GraphDebugInfo.FileLineCol")
    initpos = position(e.io)
    x.file_index != zero(Int32) && PB.encode(e, 1, x.file_index)
    x.line != zero(Int32) && PB.encode(e, 2, x.line)
    x.col != zero(Int32) && PB.encode(e, 3, x.col)
    !isempty(x.func) && PB.encode(e, 4, x.func)
    !isempty(x.code) && PB.encode(e, 5, x.code)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"GraphDebugInfo.FileLineCol")
    encoded_size = 0
    x.file_index != zero(Int32) && (encoded_size += PB._encoded_size(x.file_index, 1))
    x.line != zero(Int32) && (encoded_size += PB._encoded_size(x.line, 2))
    x.col != zero(Int32) && (encoded_size += PB._encoded_size(x.col, 3))
    !isempty(x.func) && (encoded_size += PB._encoded_size(x.func, 4))
    !isempty(x.code) && (encoded_size += PB._encoded_size(x.code, 5))
    return encoded_size
end

struct var"GraphDebugInfo.StackTrace"
    file_line_cols::Vector{var"GraphDebugInfo.FileLineCol"}
    frame_id::Vector{UInt64}
end
PB.default_values(::Type{var"GraphDebugInfo.StackTrace"}) = (;file_line_cols = Vector{var"GraphDebugInfo.FileLineCol"}(), frame_id = Vector{UInt64}())
PB.field_numbers(::Type{var"GraphDebugInfo.StackTrace"}) = (;file_line_cols = 1, frame_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"GraphDebugInfo.StackTrace"})
    file_line_cols = PB.BufferedVector{var"GraphDebugInfo.FileLineCol"}()
    frame_id = PB.BufferedVector{UInt64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, file_line_cols)
        elseif field_number == 2
            PB.decode!(d, wire_type, frame_id, Val{:fixed})
        else
            PB.skip(d, wire_type)
        end
    end
    return var"GraphDebugInfo.StackTrace"(file_line_cols[], frame_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"GraphDebugInfo.StackTrace")
    initpos = position(e.io)
    !isempty(x.file_line_cols) && PB.encode(e, 1, x.file_line_cols)
    !isempty(x.frame_id) && PB.encode(e, 2, x.frame_id, Val{:fixed})
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"GraphDebugInfo.StackTrace")
    encoded_size = 0
    !isempty(x.file_line_cols) && (encoded_size += PB._encoded_size(x.file_line_cols, 1))
    !isempty(x.frame_id) && (encoded_size += PB._encoded_size(x.frame_id, 2, Val{:fixed}))
    return encoded_size
end

struct GraphDebugInfo
    files::Vector{String}
    frames_by_id::Dict{UInt64,var"GraphDebugInfo.FileLineCol"}
    traces_by_id::Dict{UInt64,var"GraphDebugInfo.StackTrace"}
    traces::Dict{String,var"GraphDebugInfo.StackTrace"}
    name_to_trace_id::Dict{String,UInt64}
end
PB.default_values(::Type{GraphDebugInfo}) = (;files = Vector{String}(), frames_by_id = Dict{UInt64,var"GraphDebugInfo.FileLineCol"}(), traces_by_id = Dict{UInt64,var"GraphDebugInfo.StackTrace"}(), traces = Dict{String,var"GraphDebugInfo.StackTrace"}(), name_to_trace_id = Dict{String,UInt64}())
PB.field_numbers(::Type{GraphDebugInfo}) = (;files = 1, frames_by_id = 4, traces_by_id = 6, traces = 2, name_to_trace_id = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphDebugInfo})
    files = PB.BufferedVector{String}()
    frames_by_id = Dict{UInt64,var"GraphDebugInfo.FileLineCol"}()
    traces_by_id = Dict{UInt64,var"GraphDebugInfo.StackTrace"}()
    traces = Dict{String,var"GraphDebugInfo.StackTrace"}()
    name_to_trace_id = Dict{String,UInt64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, files)
        elseif field_number == 4
            PB.decode!(d, frames_by_id, Val{Tuple{:fixed,Nothing}})
        elseif field_number == 6
            PB.decode!(d, traces_by_id, Val{Tuple{:fixed,Nothing}})
        elseif field_number == 2
            PB.decode!(d, traces)
        elseif field_number == 5
            PB.decode!(d, name_to_trace_id, Val{Tuple{Nothing,:fixed}})
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphDebugInfo(files[], frames_by_id, traces_by_id, traces, name_to_trace_id)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphDebugInfo)
    initpos = position(e.io)
    !isempty(x.files) && PB.encode(e, 1, x.files)
    !isempty(x.frames_by_id) && PB.encode(e, 4, x.frames_by_id, Val{Tuple{:fixed,Nothing}})
    !isempty(x.traces_by_id) && PB.encode(e, 6, x.traces_by_id, Val{Tuple{:fixed,Nothing}})
    !isempty(x.traces) && PB.encode(e, 2, x.traces)
    !isempty(x.name_to_trace_id) && PB.encode(e, 5, x.name_to_trace_id, Val{Tuple{Nothing,:fixed}})
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphDebugInfo)
    encoded_size = 0
    !isempty(x.files) && (encoded_size += PB._encoded_size(x.files, 1))
    !isempty(x.frames_by_id) && (encoded_size += PB._encoded_size(x.frames_by_id, 4, Val{Tuple{:fixed,Nothing}}))
    !isempty(x.traces_by_id) && (encoded_size += PB._encoded_size(x.traces_by_id, 6, Val{Tuple{:fixed,Nothing}}))
    !isempty(x.traces) && (encoded_size += PB._encoded_size(x.traces, 2))
    !isempty(x.name_to_trace_id) && (encoded_size += PB._encoded_size(x.name_to_trace_id, 5, Val{Tuple{Nothing,:fixed}}))
    return encoded_size
end
