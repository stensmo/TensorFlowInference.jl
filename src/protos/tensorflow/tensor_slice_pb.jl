# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:44.105

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"TensorSliceProto.Extent", TensorSliceProto

struct var"TensorSliceProto.Extent"
    start::Int64
    has_length::Union{Nothing,OneOf{Int64}}
end
PB.oneof_field_types(::Type{var"TensorSliceProto.Extent"}) = (;
    has_length = (;length=Int64),
)
PB.default_values(::Type{var"TensorSliceProto.Extent"}) = (;start = zero(Int64), length = zero(Int64))
PB.field_numbers(::Type{var"TensorSliceProto.Extent"}) = (;start = 1, length = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TensorSliceProto.Extent"})
    start = zero(Int64)
    has_length = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            start = PB.decode(d, Int64)
        elseif field_number == 2
            has_length = OneOf(:length, PB.decode(d, Int64))
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TensorSliceProto.Extent"(start, has_length)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TensorSliceProto.Extent")
    initpos = position(e.io)
    x.start != zero(Int64) && PB.encode(e, 1, x.start)
    if isnothing(x.has_length);
    elseif x.has_length.name === :length
        PB.encode(e, 2, x.has_length[]::Int64)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TensorSliceProto.Extent")
    encoded_size = 0
    x.start != zero(Int64) && (encoded_size += PB._encoded_size(x.start, 1))
    if isnothing(x.has_length);
    elseif x.has_length.name === :length
        encoded_size += PB._encoded_size(x.has_length[]::Int64, 2)
    end
    return encoded_size
end

struct TensorSliceProto
    extent::Vector{var"TensorSliceProto.Extent"}
end
PB.default_values(::Type{TensorSliceProto}) = (;extent = Vector{var"TensorSliceProto.Extent"}())
PB.field_numbers(::Type{TensorSliceProto}) = (;extent = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TensorSliceProto})
    extent = PB.BufferedVector{var"TensorSliceProto.Extent"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, extent)
        else
            PB.skip(d, wire_type)
        end
    end
    return TensorSliceProto(extent[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TensorSliceProto)
    initpos = position(e.io)
    !isempty(x.extent) && PB.encode(e, 1, x.extent)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TensorSliceProto)
    encoded_size = 0
    !isempty(x.extent) && (encoded_size += PB._encoded_size(x.extent, 1))
    return encoded_size
end
