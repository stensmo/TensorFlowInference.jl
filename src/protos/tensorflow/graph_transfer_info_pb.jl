# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:44.012

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export GraphTransferConstNodeInfo, GraphTransferGraphInputNodeInfo
export var"GraphTransferInfo.Destination", GraphTransferNodeOutputInfo
export GraphTransferNodeInput, GraphTransferGraphOutputNodeInfo, GraphTransferNodeInfo
export GraphTransferNodeInputInfo, GraphTransferInfo

struct GraphTransferConstNodeInfo
    name::String
    node_id::Int32
    shape::Vector{Int64}
    data::Vector{UInt8}
    dtype::var"#DataType".T
end
PB.default_values(::Type{GraphTransferConstNodeInfo}) = (;name = "", node_id = zero(Int32), shape = Vector{Int64}(), data = UInt8[], dtype = var"#DataType".DT_INVALID)
PB.field_numbers(::Type{GraphTransferConstNodeInfo}) = (;name = 1, node_id = 2, shape = 3, data = 4, dtype = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferConstNodeInfo})
    name = ""
    node_id = zero(Int32)
    shape = PB.BufferedVector{Int64}()
    data = UInt8[]
    dtype = var"#DataType".DT_INVALID
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            node_id = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, wire_type, shape)
        elseif field_number == 4
            data = PB.decode(d, Vector{UInt8})
        elseif field_number == 5
            dtype = PB.decode(d, var"#DataType".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferConstNodeInfo(name, node_id, shape[], data, dtype)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferConstNodeInfo)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.node_id != zero(Int32) && PB.encode(e, 2, x.node_id)
    !isempty(x.shape) && PB.encode(e, 3, x.shape)
    !isempty(x.data) && PB.encode(e, 4, x.data)
    x.dtype != var"#DataType".DT_INVALID && PB.encode(e, 5, x.dtype)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferConstNodeInfo)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.node_id != zero(Int32) && (encoded_size += PB._encoded_size(x.node_id, 2))
    !isempty(x.shape) && (encoded_size += PB._encoded_size(x.shape, 3))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 4))
    x.dtype != var"#DataType".DT_INVALID && (encoded_size += PB._encoded_size(x.dtype, 5))
    return encoded_size
end

struct GraphTransferGraphInputNodeInfo
    name::String
    shape::Vector{Int64}
    dtype::var"#DataType".T
end
PB.default_values(::Type{GraphTransferGraphInputNodeInfo}) = (;name = "", shape = Vector{Int64}(), dtype = var"#DataType".DT_INVALID)
PB.field_numbers(::Type{GraphTransferGraphInputNodeInfo}) = (;name = 1, shape = 2, dtype = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferGraphInputNodeInfo})
    name = ""
    shape = PB.BufferedVector{Int64}()
    dtype = var"#DataType".DT_INVALID
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, shape)
        elseif field_number == 3
            dtype = PB.decode(d, var"#DataType".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferGraphInputNodeInfo(name, shape[], dtype)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferGraphInputNodeInfo)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.shape) && PB.encode(e, 2, x.shape)
    x.dtype != var"#DataType".DT_INVALID && PB.encode(e, 3, x.dtype)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferGraphInputNodeInfo)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.shape) && (encoded_size += PB._encoded_size(x.shape, 2))
    x.dtype != var"#DataType".DT_INVALID && (encoded_size += PB._encoded_size(x.dtype, 3))
    return encoded_size
end

@enumx var"GraphTransferInfo.Destination" NOP=0 HEXAGON=1

struct GraphTransferNodeOutputInfo
    node_id::Int32
    max_byte_size::Vector{Int32}
end
PB.default_values(::Type{GraphTransferNodeOutputInfo}) = (;node_id = zero(Int32), max_byte_size = Vector{Int32}())
PB.field_numbers(::Type{GraphTransferNodeOutputInfo}) = (;node_id = 1, max_byte_size = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferNodeOutputInfo})
    node_id = zero(Int32)
    max_byte_size = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            node_id = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, wire_type, max_byte_size)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferNodeOutputInfo(node_id, max_byte_size[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferNodeOutputInfo)
    initpos = position(e.io)
    x.node_id != zero(Int32) && PB.encode(e, 1, x.node_id)
    !isempty(x.max_byte_size) && PB.encode(e, 2, x.max_byte_size)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferNodeOutputInfo)
    encoded_size = 0
    x.node_id != zero(Int32) && (encoded_size += PB._encoded_size(x.node_id, 1))
    !isempty(x.max_byte_size) && (encoded_size += PB._encoded_size(x.max_byte_size, 2))
    return encoded_size
end

struct GraphTransferNodeInput
    node_id::Int32
    output_port::Int32
end
PB.default_values(::Type{GraphTransferNodeInput}) = (;node_id = zero(Int32), output_port = zero(Int32))
PB.field_numbers(::Type{GraphTransferNodeInput}) = (;node_id = 1, output_port = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferNodeInput})
    node_id = zero(Int32)
    output_port = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            node_id = PB.decode(d, Int32)
        elseif field_number == 2
            output_port = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferNodeInput(node_id, output_port)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferNodeInput)
    initpos = position(e.io)
    x.node_id != zero(Int32) && PB.encode(e, 1, x.node_id)
    x.output_port != zero(Int32) && PB.encode(e, 2, x.output_port)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferNodeInput)
    encoded_size = 0
    x.node_id != zero(Int32) && (encoded_size += PB._encoded_size(x.node_id, 1))
    x.output_port != zero(Int32) && (encoded_size += PB._encoded_size(x.output_port, 2))
    return encoded_size
end

struct GraphTransferGraphOutputNodeInfo
    name::String
    shape::Vector{Int64}
    dtype::var"#DataType".T
end
PB.default_values(::Type{GraphTransferGraphOutputNodeInfo}) = (;name = "", shape = Vector{Int64}(), dtype = var"#DataType".DT_INVALID)
PB.field_numbers(::Type{GraphTransferGraphOutputNodeInfo}) = (;name = 1, shape = 2, dtype = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferGraphOutputNodeInfo})
    name = ""
    shape = PB.BufferedVector{Int64}()
    dtype = var"#DataType".DT_INVALID
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, shape)
        elseif field_number == 3
            dtype = PB.decode(d, var"#DataType".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferGraphOutputNodeInfo(name, shape[], dtype)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferGraphOutputNodeInfo)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.shape) && PB.encode(e, 2, x.shape)
    x.dtype != var"#DataType".DT_INVALID && PB.encode(e, 3, x.dtype)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferGraphOutputNodeInfo)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.shape) && (encoded_size += PB._encoded_size(x.shape, 2))
    x.dtype != var"#DataType".DT_INVALID && (encoded_size += PB._encoded_size(x.dtype, 3))
    return encoded_size
end

struct GraphTransferNodeInfo
    name::String
    node_id::Int32
    type_name::String
    soc_op_id::Int32
    padding_id::Int32
    input_count::Int32
    output_count::Int32
end
PB.default_values(::Type{GraphTransferNodeInfo}) = (;name = "", node_id = zero(Int32), type_name = "", soc_op_id = zero(Int32), padding_id = zero(Int32), input_count = zero(Int32), output_count = zero(Int32))
PB.field_numbers(::Type{GraphTransferNodeInfo}) = (;name = 1, node_id = 2, type_name = 3, soc_op_id = 4, padding_id = 5, input_count = 6, output_count = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferNodeInfo})
    name = ""
    node_id = zero(Int32)
    type_name = ""
    soc_op_id = zero(Int32)
    padding_id = zero(Int32)
    input_count = zero(Int32)
    output_count = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            node_id = PB.decode(d, Int32)
        elseif field_number == 3
            type_name = PB.decode(d, String)
        elseif field_number == 4
            soc_op_id = PB.decode(d, Int32)
        elseif field_number == 5
            padding_id = PB.decode(d, Int32)
        elseif field_number == 6
            input_count = PB.decode(d, Int32)
        elseif field_number == 7
            output_count = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferNodeInfo(name, node_id, type_name, soc_op_id, padding_id, input_count, output_count)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferNodeInfo)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.node_id != zero(Int32) && PB.encode(e, 2, x.node_id)
    !isempty(x.type_name) && PB.encode(e, 3, x.type_name)
    x.soc_op_id != zero(Int32) && PB.encode(e, 4, x.soc_op_id)
    x.padding_id != zero(Int32) && PB.encode(e, 5, x.padding_id)
    x.input_count != zero(Int32) && PB.encode(e, 6, x.input_count)
    x.output_count != zero(Int32) && PB.encode(e, 7, x.output_count)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferNodeInfo)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.node_id != zero(Int32) && (encoded_size += PB._encoded_size(x.node_id, 2))
    !isempty(x.type_name) && (encoded_size += PB._encoded_size(x.type_name, 3))
    x.soc_op_id != zero(Int32) && (encoded_size += PB._encoded_size(x.soc_op_id, 4))
    x.padding_id != zero(Int32) && (encoded_size += PB._encoded_size(x.padding_id, 5))
    x.input_count != zero(Int32) && (encoded_size += PB._encoded_size(x.input_count, 6))
    x.output_count != zero(Int32) && (encoded_size += PB._encoded_size(x.output_count, 7))
    return encoded_size
end

struct GraphTransferNodeInputInfo
    node_id::Int32
    node_input::Vector{GraphTransferNodeInput}
end
PB.default_values(::Type{GraphTransferNodeInputInfo}) = (;node_id = zero(Int32), node_input = Vector{GraphTransferNodeInput}())
PB.field_numbers(::Type{GraphTransferNodeInputInfo}) = (;node_id = 1, node_input = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferNodeInputInfo})
    node_id = zero(Int32)
    node_input = PB.BufferedVector{GraphTransferNodeInput}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            node_id = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, node_input)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferNodeInputInfo(node_id, node_input[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferNodeInputInfo)
    initpos = position(e.io)
    x.node_id != zero(Int32) && PB.encode(e, 1, x.node_id)
    !isempty(x.node_input) && PB.encode(e, 2, x.node_input)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferNodeInputInfo)
    encoded_size = 0
    x.node_id != zero(Int32) && (encoded_size += PB._encoded_size(x.node_id, 1))
    !isempty(x.node_input) && (encoded_size += PB._encoded_size(x.node_input, 2))
    return encoded_size
end

struct GraphTransferInfo
    node_info::Vector{GraphTransferNodeInfo}
    const_node_info::Vector{GraphTransferConstNodeInfo}
    node_input_info::Vector{GraphTransferNodeInputInfo}
    node_output_info::Vector{GraphTransferNodeOutputInfo}
    graph_input_node_info::Vector{GraphTransferGraphInputNodeInfo}
    graph_output_node_info::Vector{GraphTransferGraphOutputNodeInfo}
    destination::var"GraphTransferInfo.Destination".T
end
PB.default_values(::Type{GraphTransferInfo}) = (;node_info = Vector{GraphTransferNodeInfo}(), const_node_info = Vector{GraphTransferConstNodeInfo}(), node_input_info = Vector{GraphTransferNodeInputInfo}(), node_output_info = Vector{GraphTransferNodeOutputInfo}(), graph_input_node_info = Vector{GraphTransferGraphInputNodeInfo}(), graph_output_node_info = Vector{GraphTransferGraphOutputNodeInfo}(), destination = var"GraphTransferInfo.Destination".NOP)
PB.field_numbers(::Type{GraphTransferInfo}) = (;node_info = 1, const_node_info = 2, node_input_info = 3, node_output_info = 4, graph_input_node_info = 5, graph_output_node_info = 6, destination = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphTransferInfo})
    node_info = PB.BufferedVector{GraphTransferNodeInfo}()
    const_node_info = PB.BufferedVector{GraphTransferConstNodeInfo}()
    node_input_info = PB.BufferedVector{GraphTransferNodeInputInfo}()
    node_output_info = PB.BufferedVector{GraphTransferNodeOutputInfo}()
    graph_input_node_info = PB.BufferedVector{GraphTransferGraphInputNodeInfo}()
    graph_output_node_info = PB.BufferedVector{GraphTransferGraphOutputNodeInfo}()
    destination = var"GraphTransferInfo.Destination".NOP
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, node_info)
        elseif field_number == 2
            PB.decode!(d, const_node_info)
        elseif field_number == 3
            PB.decode!(d, node_input_info)
        elseif field_number == 4
            PB.decode!(d, node_output_info)
        elseif field_number == 5
            PB.decode!(d, graph_input_node_info)
        elseif field_number == 6
            PB.decode!(d, graph_output_node_info)
        elseif field_number == 7
            destination = PB.decode(d, var"GraphTransferInfo.Destination".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphTransferInfo(node_info[], const_node_info[], node_input_info[], node_output_info[], graph_input_node_info[], graph_output_node_info[], destination)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphTransferInfo)
    initpos = position(e.io)
    !isempty(x.node_info) && PB.encode(e, 1, x.node_info)
    !isempty(x.const_node_info) && PB.encode(e, 2, x.const_node_info)
    !isempty(x.node_input_info) && PB.encode(e, 3, x.node_input_info)
    !isempty(x.node_output_info) && PB.encode(e, 4, x.node_output_info)
    !isempty(x.graph_input_node_info) && PB.encode(e, 5, x.graph_input_node_info)
    !isempty(x.graph_output_node_info) && PB.encode(e, 6, x.graph_output_node_info)
    x.destination != var"GraphTransferInfo.Destination".NOP && PB.encode(e, 7, x.destination)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphTransferInfo)
    encoded_size = 0
    !isempty(x.node_info) && (encoded_size += PB._encoded_size(x.node_info, 1))
    !isempty(x.const_node_info) && (encoded_size += PB._encoded_size(x.const_node_info, 2))
    !isempty(x.node_input_info) && (encoded_size += PB._encoded_size(x.node_input_info, 3))
    !isempty(x.node_output_info) && (encoded_size += PB._encoded_size(x.node_output_info, 4))
    !isempty(x.graph_input_node_info) && (encoded_size += PB._encoded_size(x.graph_input_node_info, 5))
    !isempty(x.graph_output_node_info) && (encoded_size += PB._encoded_size(x.graph_output_node_info, 6))
    x.destination != var"GraphTransferInfo.Destination".NOP && (encoded_size += PB._encoded_size(x.destination, 7))
    return encoded_size
end
