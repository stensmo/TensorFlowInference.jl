# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:43.981

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export InterconnectLink, LocalLinks, DeviceLocality, DeviceAttributes

struct InterconnectLink
    device_id::Int32
    var"#type"::String
    strength::Int32
end
PB.default_values(::Type{InterconnectLink}) = (;device_id = zero(Int32), var"#type" = "", strength = zero(Int32))
PB.field_numbers(::Type{InterconnectLink}) = (;device_id = 1, var"#type" = 2, strength = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InterconnectLink})
    device_id = zero(Int32)
    var"#type" = ""
    strength = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            device_id = PB.decode(d, Int32)
        elseif field_number == 2
            var"#type" = PB.decode(d, String)
        elseif field_number == 3
            strength = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return InterconnectLink(device_id, var"#type", strength)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InterconnectLink)
    initpos = position(e.io)
    x.device_id != zero(Int32) && PB.encode(e, 1, x.device_id)
    !isempty(x.var"#type") && PB.encode(e, 2, x.var"#type")
    x.strength != zero(Int32) && PB.encode(e, 3, x.strength)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InterconnectLink)
    encoded_size = 0
    x.device_id != zero(Int32) && (encoded_size += PB._encoded_size(x.device_id, 1))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 2))
    x.strength != zero(Int32) && (encoded_size += PB._encoded_size(x.strength, 3))
    return encoded_size
end

struct LocalLinks
    link::Vector{InterconnectLink}
end
PB.default_values(::Type{LocalLinks}) = (;link = Vector{InterconnectLink}())
PB.field_numbers(::Type{LocalLinks}) = (;link = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LocalLinks})
    link = PB.BufferedVector{InterconnectLink}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, link)
        else
            PB.skip(d, wire_type)
        end
    end
    return LocalLinks(link[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LocalLinks)
    initpos = position(e.io)
    !isempty(x.link) && PB.encode(e, 1, x.link)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LocalLinks)
    encoded_size = 0
    !isempty(x.link) && (encoded_size += PB._encoded_size(x.link, 1))
    return encoded_size
end

struct DeviceLocality
    bus_id::Int32
    numa_node::Int32
    links::Union{Nothing,LocalLinks}
end
PB.default_values(::Type{DeviceLocality}) = (;bus_id = zero(Int32), numa_node = zero(Int32), links = nothing)
PB.field_numbers(::Type{DeviceLocality}) = (;bus_id = 1, numa_node = 2, links = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceLocality})
    bus_id = zero(Int32)
    numa_node = zero(Int32)
    links = Ref{Union{Nothing,LocalLinks}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            bus_id = PB.decode(d, Int32)
        elseif field_number == 2
            numa_node = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, links)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceLocality(bus_id, numa_node, links[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceLocality)
    initpos = position(e.io)
    x.bus_id != zero(Int32) && PB.encode(e, 1, x.bus_id)
    x.numa_node != zero(Int32) && PB.encode(e, 2, x.numa_node)
    !isnothing(x.links) && PB.encode(e, 3, x.links)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceLocality)
    encoded_size = 0
    x.bus_id != zero(Int32) && (encoded_size += PB._encoded_size(x.bus_id, 1))
    x.numa_node != zero(Int32) && (encoded_size += PB._encoded_size(x.numa_node, 2))
    !isnothing(x.links) && (encoded_size += PB._encoded_size(x.links, 3))
    return encoded_size
end

struct DeviceAttributes
    name::String
    device_type::String
    memory_limit::Int64
    locality::Union{Nothing,DeviceLocality}
    incarnation::UInt64
    physical_device_desc::String
    xla_global_id::Int64
end
PB.default_values(::Type{DeviceAttributes}) = (;name = "", device_type = "", memory_limit = zero(Int64), locality = nothing, incarnation = zero(UInt64), physical_device_desc = "", xla_global_id = zero(Int64))
PB.field_numbers(::Type{DeviceAttributes}) = (;name = 1, device_type = 2, memory_limit = 4, locality = 5, incarnation = 6, physical_device_desc = 7, xla_global_id = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceAttributes})
    name = ""
    device_type = ""
    memory_limit = zero(Int64)
    locality = Ref{Union{Nothing,DeviceLocality}}(nothing)
    incarnation = zero(UInt64)
    physical_device_desc = ""
    xla_global_id = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            device_type = PB.decode(d, String)
        elseif field_number == 4
            memory_limit = PB.decode(d, Int64)
        elseif field_number == 5
            PB.decode!(d, locality)
        elseif field_number == 6
            incarnation = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 7
            physical_device_desc = PB.decode(d, String)
        elseif field_number == 8
            xla_global_id = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceAttributes(name, device_type, memory_limit, locality[], incarnation, physical_device_desc, xla_global_id)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceAttributes)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.device_type) && PB.encode(e, 2, x.device_type)
    x.memory_limit != zero(Int64) && PB.encode(e, 4, x.memory_limit)
    !isnothing(x.locality) && PB.encode(e, 5, x.locality)
    x.incarnation != zero(UInt64) && PB.encode(e, 6, x.incarnation, Val{:fixed})
    !isempty(x.physical_device_desc) && PB.encode(e, 7, x.physical_device_desc)
    x.xla_global_id != zero(Int64) && PB.encode(e, 8, x.xla_global_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceAttributes)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.device_type) && (encoded_size += PB._encoded_size(x.device_type, 2))
    x.memory_limit != zero(Int64) && (encoded_size += PB._encoded_size(x.memory_limit, 4))
    !isnothing(x.locality) && (encoded_size += PB._encoded_size(x.locality, 5))
    x.incarnation != zero(UInt64) && (encoded_size += PB._encoded_size(x.incarnation, 6, Val{:fixed}))
    !isempty(x.physical_device_desc) && (encoded_size += PB._encoded_size(x.physical_device_desc, 7))
    x.xla_global_id != zero(Int64) && (encoded_size += PB._encoded_size(x.xla_global_id, 8))
    return encoded_size
end
