# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:43.981
# original file: C:\Users\erst0014\Downloads\tensorflow-2.15.0\tensorflow-2.15.0\tensorflow\core\framework\dataset_options.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export AutotuneOptions, var"CardinalityOptions.ComputeLevel", OptimizationOptions
export ThreadingOptions, ExternalStatePolicy, AutoShardPolicy, CardinalityOptions
export DistributeOptions, Options

struct AutotuneOptions
    optional_enabled::Union{Nothing,OneOf{Bool}}
    optional_cpu_budget::Union{Nothing,OneOf{Int32}}
    optional_ram_budget::Union{Nothing,OneOf{Int64}}
    optional_autotune_algorithm::Union{Nothing,OneOf{tensorflow.data.model.AutotuneAlgorithm.T}}
end
PB.oneof_field_types(::Type{AutotuneOptions}) = (;
    optional_enabled = (;enabled=Bool),
    optional_cpu_budget = (;cpu_budget=Int32),
    optional_ram_budget = (;ram_budget=Int64),
    optional_autotune_algorithm = (;autotune_algorithm=tensorflow.data.model.AutotuneAlgorithm.T),
)
PB.default_values(::Type{AutotuneOptions}) = (;enabled = false, cpu_budget = zero(Int32), ram_budget = zero(Int64), autotune_algorithm = tensorflow.data.model.AutotuneAlgorithm.DEFAULT)
PB.field_numbers(::Type{AutotuneOptions}) = (;enabled = 1, cpu_budget = 2, ram_budget = 3, autotune_algorithm = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AutotuneOptions})
    optional_enabled = nothing
    optional_cpu_budget = nothing
    optional_ram_budget = nothing
    optional_autotune_algorithm = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            optional_enabled = OneOf(:enabled, PB.decode(d, Bool))
        elseif field_number == 2
            optional_cpu_budget = OneOf(:cpu_budget, PB.decode(d, Int32))
        elseif field_number == 3
            optional_ram_budget = OneOf(:ram_budget, PB.decode(d, Int64))
        elseif field_number == 4
            optional_autotune_algorithm = OneOf(:autotune_algorithm, PB.decode(d, tensorflow.data.model.AutotuneAlgorithm.T))
        else
            PB.skip(d, wire_type)
        end
    end
    return AutotuneOptions(optional_enabled, optional_cpu_budget, optional_ram_budget, optional_autotune_algorithm)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AutotuneOptions)
    initpos = position(e.io)
    if isnothing(x.optional_enabled);
    elseif x.optional_enabled.name === :enabled
        PB.encode(e, 1, x.optional_enabled[]::Bool)
    end
    if isnothing(x.optional_cpu_budget);
    elseif x.optional_cpu_budget.name === :cpu_budget
        PB.encode(e, 2, x.optional_cpu_budget[]::Int32)
    end
    if isnothing(x.optional_ram_budget);
    elseif x.optional_ram_budget.name === :ram_budget
        PB.encode(e, 3, x.optional_ram_budget[]::Int64)
    end
    if isnothing(x.optional_autotune_algorithm);
    elseif x.optional_autotune_algorithm.name === :autotune_algorithm
        PB.encode(e, 4, x.optional_autotune_algorithm[]::tensorflow.data.model.AutotuneAlgorithm.T)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::AutotuneOptions)
    encoded_size = 0
    if isnothing(x.optional_enabled);
    elseif x.optional_enabled.name === :enabled
        encoded_size += PB._encoded_size(x.optional_enabled[]::Bool, 1)
    end
    if isnothing(x.optional_cpu_budget);
    elseif x.optional_cpu_budget.name === :cpu_budget
        encoded_size += PB._encoded_size(x.optional_cpu_budget[]::Int32, 2)
    end
    if isnothing(x.optional_ram_budget);
    elseif x.optional_ram_budget.name === :ram_budget
        encoded_size += PB._encoded_size(x.optional_ram_budget[]::Int64, 3)
    end
    if isnothing(x.optional_autotune_algorithm);
    elseif x.optional_autotune_algorithm.name === :autotune_algorithm
        encoded_size += PB._encoded_size(x.optional_autotune_algorithm[]::tensorflow.data.model.AutotuneAlgorithm.T, 4)
    end
    return encoded_size
end

@enumx var"CardinalityOptions.ComputeLevel" CARDINALITY_COMPUTE_UNSPECIFIED=0 CARDINALITY_COMPUTE_LOW=1 CARDINALITY_COMPUTE_MODERATE=2

struct OptimizationOptions
    optional_apply_default_optimizations::Union{Nothing,OneOf{Bool}}
    optional_filter_fusion::Union{Nothing,OneOf{Bool}}
    optional_map_and_batch_fusion::Union{Nothing,OneOf{Bool}}
    optional_map_and_filter_fusion::Union{Nothing,OneOf{Bool}}
    optional_map_fusion::Union{Nothing,OneOf{Bool}}
    optional_map_parallelization::Union{Nothing,OneOf{Bool}}
    optional_noop_elimination::Union{Nothing,OneOf{Bool}}
    optional_parallel_batch::Union{Nothing,OneOf{Bool}}
    optional_shuffle_and_repeat_fusion::Union{Nothing,OneOf{Bool}}
    optional_filter_parallelization::Union{Nothing,OneOf{Bool}}
    optional_inject_prefetch::Union{Nothing,OneOf{Bool}}
end
PB.reserved_fields(::Type{OptimizationOptions}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[2, 3, 4, 5, 7, 8, 13, 16, 20])
PB.oneof_field_types(::Type{OptimizationOptions}) = (;
    optional_apply_default_optimizations = (;apply_default_optimizations=Bool),
    optional_filter_fusion = (;filter_fusion=Bool),
    optional_map_and_batch_fusion = (;map_and_batch_fusion=Bool),
    optional_map_and_filter_fusion = (;map_and_filter_fusion=Bool),
    optional_map_fusion = (;map_fusion=Bool),
    optional_map_parallelization = (;map_parallelization=Bool),
    optional_noop_elimination = (;noop_elimination=Bool),
    optional_parallel_batch = (;parallel_batch=Bool),
    optional_shuffle_and_repeat_fusion = (;shuffle_and_repeat_fusion=Bool),
    optional_filter_parallelization = (;filter_parallelization=Bool),
    optional_inject_prefetch = (;inject_prefetch=Bool),
)
PB.default_values(::Type{OptimizationOptions}) = (;apply_default_optimizations = false, filter_fusion = false, map_and_batch_fusion = false, map_and_filter_fusion = false, map_fusion = false, map_parallelization = false, noop_elimination = false, parallel_batch = false, shuffle_and_repeat_fusion = false, filter_parallelization = false, inject_prefetch = false)
PB.field_numbers(::Type{OptimizationOptions}) = (;apply_default_optimizations = 1, filter_fusion = 6, map_and_batch_fusion = 9, map_and_filter_fusion = 10, map_fusion = 11, map_parallelization = 12, noop_elimination = 14, parallel_batch = 15, shuffle_and_repeat_fusion = 17, filter_parallelization = 18, inject_prefetch = 19)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OptimizationOptions})
    optional_apply_default_optimizations = nothing
    optional_filter_fusion = nothing
    optional_map_and_batch_fusion = nothing
    optional_map_and_filter_fusion = nothing
    optional_map_fusion = nothing
    optional_map_parallelization = nothing
    optional_noop_elimination = nothing
    optional_parallel_batch = nothing
    optional_shuffle_and_repeat_fusion = nothing
    optional_filter_parallelization = nothing
    optional_inject_prefetch = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            optional_apply_default_optimizations = OneOf(:apply_default_optimizations, PB.decode(d, Bool))
        elseif field_number == 6
            optional_filter_fusion = OneOf(:filter_fusion, PB.decode(d, Bool))
        elseif field_number == 9
            optional_map_and_batch_fusion = OneOf(:map_and_batch_fusion, PB.decode(d, Bool))
        elseif field_number == 10
            optional_map_and_filter_fusion = OneOf(:map_and_filter_fusion, PB.decode(d, Bool))
        elseif field_number == 11
            optional_map_fusion = OneOf(:map_fusion, PB.decode(d, Bool))
        elseif field_number == 12
            optional_map_parallelization = OneOf(:map_parallelization, PB.decode(d, Bool))
        elseif field_number == 14
            optional_noop_elimination = OneOf(:noop_elimination, PB.decode(d, Bool))
        elseif field_number == 15
            optional_parallel_batch = OneOf(:parallel_batch, PB.decode(d, Bool))
        elseif field_number == 17
            optional_shuffle_and_repeat_fusion = OneOf(:shuffle_and_repeat_fusion, PB.decode(d, Bool))
        elseif field_number == 18
            optional_filter_parallelization = OneOf(:filter_parallelization, PB.decode(d, Bool))
        elseif field_number == 19
            optional_inject_prefetch = OneOf(:inject_prefetch, PB.decode(d, Bool))
        else
            PB.skip(d, wire_type)
        end
    end
    return OptimizationOptions(optional_apply_default_optimizations, optional_filter_fusion, optional_map_and_batch_fusion, optional_map_and_filter_fusion, optional_map_fusion, optional_map_parallelization, optional_noop_elimination, optional_parallel_batch, optional_shuffle_and_repeat_fusion, optional_filter_parallelization, optional_inject_prefetch)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OptimizationOptions)
    initpos = position(e.io)
    if isnothing(x.optional_apply_default_optimizations);
    elseif x.optional_apply_default_optimizations.name === :apply_default_optimizations
        PB.encode(e, 1, x.optional_apply_default_optimizations[]::Bool)
    end
    if isnothing(x.optional_filter_fusion);
    elseif x.optional_filter_fusion.name === :filter_fusion
        PB.encode(e, 6, x.optional_filter_fusion[]::Bool)
    end
    if isnothing(x.optional_map_and_batch_fusion);
    elseif x.optional_map_and_batch_fusion.name === :map_and_batch_fusion
        PB.encode(e, 9, x.optional_map_and_batch_fusion[]::Bool)
    end
    if isnothing(x.optional_map_and_filter_fusion);
    elseif x.optional_map_and_filter_fusion.name === :map_and_filter_fusion
        PB.encode(e, 10, x.optional_map_and_filter_fusion[]::Bool)
    end
    if isnothing(x.optional_map_fusion);
    elseif x.optional_map_fusion.name === :map_fusion
        PB.encode(e, 11, x.optional_map_fusion[]::Bool)
    end
    if isnothing(x.optional_map_parallelization);
    elseif x.optional_map_parallelization.name === :map_parallelization
        PB.encode(e, 12, x.optional_map_parallelization[]::Bool)
    end
    if isnothing(x.optional_noop_elimination);
    elseif x.optional_noop_elimination.name === :noop_elimination
        PB.encode(e, 14, x.optional_noop_elimination[]::Bool)
    end
    if isnothing(x.optional_parallel_batch);
    elseif x.optional_parallel_batch.name === :parallel_batch
        PB.encode(e, 15, x.optional_parallel_batch[]::Bool)
    end
    if isnothing(x.optional_shuffle_and_repeat_fusion);
    elseif x.optional_shuffle_and_repeat_fusion.name === :shuffle_and_repeat_fusion
        PB.encode(e, 17, x.optional_shuffle_and_repeat_fusion[]::Bool)
    end
    if isnothing(x.optional_filter_parallelization);
    elseif x.optional_filter_parallelization.name === :filter_parallelization
        PB.encode(e, 18, x.optional_filter_parallelization[]::Bool)
    end
    if isnothing(x.optional_inject_prefetch);
    elseif x.optional_inject_prefetch.name === :inject_prefetch
        PB.encode(e, 19, x.optional_inject_prefetch[]::Bool)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::OptimizationOptions)
    encoded_size = 0
    if isnothing(x.optional_apply_default_optimizations);
    elseif x.optional_apply_default_optimizations.name === :apply_default_optimizations
        encoded_size += PB._encoded_size(x.optional_apply_default_optimizations[]::Bool, 1)
    end
    if isnothing(x.optional_filter_fusion);
    elseif x.optional_filter_fusion.name === :filter_fusion
        encoded_size += PB._encoded_size(x.optional_filter_fusion[]::Bool, 6)
    end
    if isnothing(x.optional_map_and_batch_fusion);
    elseif x.optional_map_and_batch_fusion.name === :map_and_batch_fusion
        encoded_size += PB._encoded_size(x.optional_map_and_batch_fusion[]::Bool, 9)
    end
    if isnothing(x.optional_map_and_filter_fusion);
    elseif x.optional_map_and_filter_fusion.name === :map_and_filter_fusion
        encoded_size += PB._encoded_size(x.optional_map_and_filter_fusion[]::Bool, 10)
    end
    if isnothing(x.optional_map_fusion);
    elseif x.optional_map_fusion.name === :map_fusion
        encoded_size += PB._encoded_size(x.optional_map_fusion[]::Bool, 11)
    end
    if isnothing(x.optional_map_parallelization);
    elseif x.optional_map_parallelization.name === :map_parallelization
        encoded_size += PB._encoded_size(x.optional_map_parallelization[]::Bool, 12)
    end
    if isnothing(x.optional_noop_elimination);
    elseif x.optional_noop_elimination.name === :noop_elimination
        encoded_size += PB._encoded_size(x.optional_noop_elimination[]::Bool, 14)
    end
    if isnothing(x.optional_parallel_batch);
    elseif x.optional_parallel_batch.name === :parallel_batch
        encoded_size += PB._encoded_size(x.optional_parallel_batch[]::Bool, 15)
    end
    if isnothing(x.optional_shuffle_and_repeat_fusion);
    elseif x.optional_shuffle_and_repeat_fusion.name === :shuffle_and_repeat_fusion
        encoded_size += PB._encoded_size(x.optional_shuffle_and_repeat_fusion[]::Bool, 17)
    end
    if isnothing(x.optional_filter_parallelization);
    elseif x.optional_filter_parallelization.name === :filter_parallelization
        encoded_size += PB._encoded_size(x.optional_filter_parallelization[]::Bool, 18)
    end
    if isnothing(x.optional_inject_prefetch);
    elseif x.optional_inject_prefetch.name === :inject_prefetch
        encoded_size += PB._encoded_size(x.optional_inject_prefetch[]::Bool, 19)
    end
    return encoded_size
end

struct ThreadingOptions
    optional_max_intra_op_parallelism::Union{Nothing,OneOf{Int32}}
    optional_private_threadpool_size::Union{Nothing,OneOf{Int32}}
end
PB.oneof_field_types(::Type{ThreadingOptions}) = (;
    optional_max_intra_op_parallelism = (;max_intra_op_parallelism=Int32),
    optional_private_threadpool_size = (;private_threadpool_size=Int32),
)
PB.default_values(::Type{ThreadingOptions}) = (;max_intra_op_parallelism = zero(Int32), private_threadpool_size = zero(Int32))
PB.field_numbers(::Type{ThreadingOptions}) = (;max_intra_op_parallelism = 1, private_threadpool_size = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ThreadingOptions})
    optional_max_intra_op_parallelism = nothing
    optional_private_threadpool_size = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            optional_max_intra_op_parallelism = OneOf(:max_intra_op_parallelism, PB.decode(d, Int32))
        elseif field_number == 2
            optional_private_threadpool_size = OneOf(:private_threadpool_size, PB.decode(d, Int32))
        else
            PB.skip(d, wire_type)
        end
    end
    return ThreadingOptions(optional_max_intra_op_parallelism, optional_private_threadpool_size)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ThreadingOptions)
    initpos = position(e.io)
    if isnothing(x.optional_max_intra_op_parallelism);
    elseif x.optional_max_intra_op_parallelism.name === :max_intra_op_parallelism
        PB.encode(e, 1, x.optional_max_intra_op_parallelism[]::Int32)
    end
    if isnothing(x.optional_private_threadpool_size);
    elseif x.optional_private_threadpool_size.name === :private_threadpool_size
        PB.encode(e, 2, x.optional_private_threadpool_size[]::Int32)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::ThreadingOptions)
    encoded_size = 0
    if isnothing(x.optional_max_intra_op_parallelism);
    elseif x.optional_max_intra_op_parallelism.name === :max_intra_op_parallelism
        encoded_size += PB._encoded_size(x.optional_max_intra_op_parallelism[]::Int32, 1)
    end
    if isnothing(x.optional_private_threadpool_size);
    elseif x.optional_private_threadpool_size.name === :private_threadpool_size
        encoded_size += PB._encoded_size(x.optional_private_threadpool_size[]::Int32, 2)
    end
    return encoded_size
end

@enumx ExternalStatePolicy POLICY_WARN=0 POLICY_IGNORE=1 POLICY_FAIL=2

@enumx AutoShardPolicy AUTO=0 FILE=1 DATA=2 HINT=3 OFF=-1

struct CardinalityOptions
    compute_level::var"CardinalityOptions.ComputeLevel".T
end
PB.default_values(::Type{CardinalityOptions}) = (;compute_level = var"CardinalityOptions.ComputeLevel".CARDINALITY_COMPUTE_UNSPECIFIED)
PB.field_numbers(::Type{CardinalityOptions}) = (;compute_level = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CardinalityOptions})
    compute_level = var"CardinalityOptions.ComputeLevel".CARDINALITY_COMPUTE_UNSPECIFIED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            compute_level = PB.decode(d, var"CardinalityOptions.ComputeLevel".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return CardinalityOptions(compute_level)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CardinalityOptions)
    initpos = position(e.io)
    x.compute_level != var"CardinalityOptions.ComputeLevel".CARDINALITY_COMPUTE_UNSPECIFIED && PB.encode(e, 1, x.compute_level)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CardinalityOptions)
    encoded_size = 0
    x.compute_level != var"CardinalityOptions.ComputeLevel".CARDINALITY_COMPUTE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.compute_level, 1))
    return encoded_size
end

struct DistributeOptions
    auto_shard_policy::AutoShardPolicy.T
    optional_num_devices::Union{Nothing,OneOf{Int32}}
end
PB.oneof_field_types(::Type{DistributeOptions}) = (;
    optional_num_devices = (;num_devices=Int32),
)
PB.default_values(::Type{DistributeOptions}) = (;auto_shard_policy = AutoShardPolicy.AUTO, num_devices = zero(Int32))
PB.field_numbers(::Type{DistributeOptions}) = (;auto_shard_policy = 1, num_devices = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DistributeOptions})
    auto_shard_policy = AutoShardPolicy.AUTO
    optional_num_devices = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            auto_shard_policy = PB.decode(d, AutoShardPolicy.T)
        elseif field_number == 2
            optional_num_devices = OneOf(:num_devices, PB.decode(d, Int32))
        else
            PB.skip(d, wire_type)
        end
    end
    return DistributeOptions(auto_shard_policy, optional_num_devices)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DistributeOptions)
    initpos = position(e.io)
    x.auto_shard_policy != AutoShardPolicy.AUTO && PB.encode(e, 1, x.auto_shard_policy)
    if isnothing(x.optional_num_devices);
    elseif x.optional_num_devices.name === :num_devices
        PB.encode(e, 2, x.optional_num_devices[]::Int32)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::DistributeOptions)
    encoded_size = 0
    x.auto_shard_policy != AutoShardPolicy.AUTO && (encoded_size += PB._encoded_size(x.auto_shard_policy, 1))
    if isnothing(x.optional_num_devices);
    elseif x.optional_num_devices.name === :num_devices
        encoded_size += PB._encoded_size(x.optional_num_devices[]::Int32, 2)
    end
    return encoded_size
end

struct Options
    optional_deterministic::Union{Nothing,OneOf{Bool}}
    autotune_options::Union{Nothing,AutotuneOptions}
    distribute_options::Union{Nothing,DistributeOptions}
    optimization_options::Union{Nothing,OptimizationOptions}
    optional_slack::Union{Nothing,OneOf{Bool}}
    threading_options::Union{Nothing,ThreadingOptions}
    optional_external_state_policy::Union{Nothing,OneOf{ExternalStatePolicy.T}}
    optional_symbolic_checkpoint::Union{Nothing,OneOf{Bool}}
    optional_warm_start::Union{Nothing,OneOf{Bool}}
end
PB.oneof_field_types(::Type{Options}) = (;
    optional_deterministic = (;deterministic=Bool),
    optional_slack = (;slack=Bool),
    optional_external_state_policy = (;external_state_policy=ExternalStatePolicy.T),
    optional_symbolic_checkpoint = (;symbolic_checkpoint=Bool),
    optional_warm_start = (;warm_start=Bool),
)
PB.default_values(::Type{Options}) = (;deterministic = false, autotune_options = nothing, distribute_options = nothing, optimization_options = nothing, slack = false, threading_options = nothing, external_state_policy = ExternalStatePolicy.POLICY_WARN, symbolic_checkpoint = false, warm_start = false)
PB.field_numbers(::Type{Options}) = (;deterministic = 1, autotune_options = 7, distribute_options = 2, optimization_options = 3, slack = 4, threading_options = 5, external_state_policy = 6, symbolic_checkpoint = 8, warm_start = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Options})
    optional_deterministic = nothing
    autotune_options = Ref{Union{Nothing,AutotuneOptions}}(nothing)
    distribute_options = Ref{Union{Nothing,DistributeOptions}}(nothing)
    optimization_options = Ref{Union{Nothing,OptimizationOptions}}(nothing)
    optional_slack = nothing
    threading_options = Ref{Union{Nothing,ThreadingOptions}}(nothing)
    optional_external_state_policy = nothing
    optional_symbolic_checkpoint = nothing
    optional_warm_start = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            optional_deterministic = OneOf(:deterministic, PB.decode(d, Bool))
        elseif field_number == 7
            PB.decode!(d, autotune_options)
        elseif field_number == 2
            PB.decode!(d, distribute_options)
        elseif field_number == 3
            PB.decode!(d, optimization_options)
        elseif field_number == 4
            optional_slack = OneOf(:slack, PB.decode(d, Bool))
        elseif field_number == 5
            PB.decode!(d, threading_options)
        elseif field_number == 6
            optional_external_state_policy = OneOf(:external_state_policy, PB.decode(d, ExternalStatePolicy.T))
        elseif field_number == 8
            optional_symbolic_checkpoint = OneOf(:symbolic_checkpoint, PB.decode(d, Bool))
        elseif field_number == 9
            optional_warm_start = OneOf(:warm_start, PB.decode(d, Bool))
        else
            PB.skip(d, wire_type)
        end
    end
    return Options(optional_deterministic, autotune_options[], distribute_options[], optimization_options[], optional_slack, threading_options[], optional_external_state_policy, optional_symbolic_checkpoint, optional_warm_start)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Options)
    initpos = position(e.io)
    if isnothing(x.optional_deterministic);
    elseif x.optional_deterministic.name === :deterministic
        PB.encode(e, 1, x.optional_deterministic[]::Bool)
    end
    !isnothing(x.autotune_options) && PB.encode(e, 7, x.autotune_options)
    !isnothing(x.distribute_options) && PB.encode(e, 2, x.distribute_options)
    !isnothing(x.optimization_options) && PB.encode(e, 3, x.optimization_options)
    if isnothing(x.optional_slack);
    elseif x.optional_slack.name === :slack
        PB.encode(e, 4, x.optional_slack[]::Bool)
    end
    !isnothing(x.threading_options) && PB.encode(e, 5, x.threading_options)
    if isnothing(x.optional_external_state_policy);
    elseif x.optional_external_state_policy.name === :external_state_policy
        PB.encode(e, 6, x.optional_external_state_policy[]::ExternalStatePolicy.T)
    end
    if isnothing(x.optional_symbolic_checkpoint);
    elseif x.optional_symbolic_checkpoint.name === :symbolic_checkpoint
        PB.encode(e, 8, x.optional_symbolic_checkpoint[]::Bool)
    end
    if isnothing(x.optional_warm_start);
    elseif x.optional_warm_start.name === :warm_start
        PB.encode(e, 9, x.optional_warm_start[]::Bool)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Options)
    encoded_size = 0
    if isnothing(x.optional_deterministic);
    elseif x.optional_deterministic.name === :deterministic
        encoded_size += PB._encoded_size(x.optional_deterministic[]::Bool, 1)
    end
    !isnothing(x.autotune_options) && (encoded_size += PB._encoded_size(x.autotune_options, 7))
    !isnothing(x.distribute_options) && (encoded_size += PB._encoded_size(x.distribute_options, 2))
    !isnothing(x.optimization_options) && (encoded_size += PB._encoded_size(x.optimization_options, 3))
    if isnothing(x.optional_slack);
    elseif x.optional_slack.name === :slack
        encoded_size += PB._encoded_size(x.optional_slack[]::Bool, 4)
    end
    !isnothing(x.threading_options) && (encoded_size += PB._encoded_size(x.threading_options, 5))
    if isnothing(x.optional_external_state_policy);
    elseif x.optional_external_state_policy.name === :external_state_policy
        encoded_size += PB._encoded_size(x.optional_external_state_policy[]::ExternalStatePolicy.T, 6)
    end
    if isnothing(x.optional_symbolic_checkpoint);
    elseif x.optional_symbolic_checkpoint.name === :symbolic_checkpoint
        encoded_size += PB._encoded_size(x.optional_symbolic_checkpoint[]::Bool, 8)
    end
    if isnothing(x.optional_warm_start);
    elseif x.optional_warm_start.name === :warm_start
        encoded_size += PB._encoded_size(x.optional_warm_start[]::Bool, 9)
    end
    return encoded_size
end
