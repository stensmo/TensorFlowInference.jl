# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:44.028

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"ModelProto.Node.Parameter", NodeClass, AutotuneAlgorithm, var"ModelProto.Node"
export var"ModelProto.OptimizationParams", ModelProto

struct var"ModelProto.Node.Parameter"
    name::String
    value::Float64
    state_value::Float64
    min::Float64
    max::Float64
    tunable::Bool
end
PB.default_values(::Type{var"ModelProto.Node.Parameter"}) = (;name = "", value = zero(Float64), state_value = zero(Float64), min = zero(Float64), max = zero(Float64), tunable = false)
PB.field_numbers(::Type{var"ModelProto.Node.Parameter"}) = (;name = 1, value = 2, state_value = 3, min = 4, max = 5, tunable = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelProto.Node.Parameter"})
    name = ""
    value = zero(Float64)
    state_value = zero(Float64)
    min = zero(Float64)
    max = zero(Float64)
    tunable = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            value = PB.decode(d, Float64)
        elseif field_number == 3
            state_value = PB.decode(d, Float64)
        elseif field_number == 4
            min = PB.decode(d, Float64)
        elseif field_number == 5
            max = PB.decode(d, Float64)
        elseif field_number == 6
            tunable = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelProto.Node.Parameter"(name, value, state_value, min, max, tunable)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelProto.Node.Parameter")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.value != zero(Float64) && PB.encode(e, 2, x.value)
    x.state_value != zero(Float64) && PB.encode(e, 3, x.state_value)
    x.min != zero(Float64) && PB.encode(e, 4, x.min)
    x.max != zero(Float64) && PB.encode(e, 5, x.max)
    x.tunable != false && PB.encode(e, 6, x.tunable)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelProto.Node.Parameter")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.value != zero(Float64) && (encoded_size += PB._encoded_size(x.value, 2))
    x.state_value != zero(Float64) && (encoded_size += PB._encoded_size(x.state_value, 3))
    x.min != zero(Float64) && (encoded_size += PB._encoded_size(x.min, 4))
    x.max != zero(Float64) && (encoded_size += PB._encoded_size(x.max, 5))
    x.tunable != false && (encoded_size += PB._encoded_size(x.tunable, 6))
    return encoded_size
end

@enumx NodeClass UNKNOWN=0 INTERLEAVE_MANY=1 ASYNC_INTERLEAVE_MANY=2 KNOWN_RATIO=3 ASYNC_KNOWN_RATIO=4 UNKNOWN_RATIO=5 ASYNC_UNKNOWN_RATIO=6

@enumx AutotuneAlgorithm DEFAULT=0 HILL_CLIMB=1 GRADIENT_DESCENT=2 MAX_PARALLELISM=3 STAGE_BASED=4

struct var"ModelProto.Node"
    id::Int64
    name::String
    autotune::Bool
    buffered_bytes::Int64
    buffered_elements::Int64
    bytes_consumed::Int64
    bytes_produced::Int64
    num_elements::Int64
    processing_time::Int64
    record_metrics::Bool
    parameters::Vector{var"ModelProto.Node.Parameter"}
    input_processing_time_sum::Float64
    input_processing_time_count::Int64
    inputs::Vector{Int64}
    node_class::NodeClass.T
    ratio::Float64
    memory_ratio::Float64
end
PB.default_values(::Type{var"ModelProto.Node"}) = (;id = zero(Int64), name = "", autotune = false, buffered_bytes = zero(Int64), buffered_elements = zero(Int64), bytes_consumed = zero(Int64), bytes_produced = zero(Int64), num_elements = zero(Int64), processing_time = zero(Int64), record_metrics = false, parameters = Vector{var"ModelProto.Node.Parameter"}(), input_processing_time_sum = zero(Float64), input_processing_time_count = zero(Int64), inputs = Vector{Int64}(), node_class = NodeClass.UNKNOWN, ratio = zero(Float64), memory_ratio = zero(Float64))
PB.field_numbers(::Type{var"ModelProto.Node"}) = (;id = 1, name = 2, autotune = 3, buffered_bytes = 4, buffered_elements = 5, bytes_consumed = 6, bytes_produced = 7, num_elements = 8, processing_time = 9, record_metrics = 10, parameters = 11, input_processing_time_sum = 12, input_processing_time_count = 13, inputs = 14, node_class = 15, ratio = 16, memory_ratio = 17)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelProto.Node"})
    id = zero(Int64)
    name = ""
    autotune = false
    buffered_bytes = zero(Int64)
    buffered_elements = zero(Int64)
    bytes_consumed = zero(Int64)
    bytes_produced = zero(Int64)
    num_elements = zero(Int64)
    processing_time = zero(Int64)
    record_metrics = false
    parameters = PB.BufferedVector{var"ModelProto.Node.Parameter"}()
    input_processing_time_sum = zero(Float64)
    input_processing_time_count = zero(Int64)
    inputs = PB.BufferedVector{Int64}()
    node_class = NodeClass.UNKNOWN
    ratio = zero(Float64)
    memory_ratio = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, Int64)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            autotune = PB.decode(d, Bool)
        elseif field_number == 4
            buffered_bytes = PB.decode(d, Int64)
        elseif field_number == 5
            buffered_elements = PB.decode(d, Int64)
        elseif field_number == 6
            bytes_consumed = PB.decode(d, Int64)
        elseif field_number == 7
            bytes_produced = PB.decode(d, Int64)
        elseif field_number == 8
            num_elements = PB.decode(d, Int64)
        elseif field_number == 9
            processing_time = PB.decode(d, Int64)
        elseif field_number == 10
            record_metrics = PB.decode(d, Bool)
        elseif field_number == 11
            PB.decode!(d, parameters)
        elseif field_number == 12
            input_processing_time_sum = PB.decode(d, Float64)
        elseif field_number == 13
            input_processing_time_count = PB.decode(d, Int64)
        elseif field_number == 14
            PB.decode!(d, wire_type, inputs)
        elseif field_number == 15
            node_class = PB.decode(d, NodeClass.T)
        elseif field_number == 16
            ratio = PB.decode(d, Float64)
        elseif field_number == 17
            memory_ratio = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelProto.Node"(id, name, autotune, buffered_bytes, buffered_elements, bytes_consumed, bytes_produced, num_elements, processing_time, record_metrics, parameters[], input_processing_time_sum, input_processing_time_count, inputs[], node_class, ratio, memory_ratio)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelProto.Node")
    initpos = position(e.io)
    x.id != zero(Int64) && PB.encode(e, 1, x.id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    x.autotune != false && PB.encode(e, 3, x.autotune)
    x.buffered_bytes != zero(Int64) && PB.encode(e, 4, x.buffered_bytes)
    x.buffered_elements != zero(Int64) && PB.encode(e, 5, x.buffered_elements)
    x.bytes_consumed != zero(Int64) && PB.encode(e, 6, x.bytes_consumed)
    x.bytes_produced != zero(Int64) && PB.encode(e, 7, x.bytes_produced)
    x.num_elements != zero(Int64) && PB.encode(e, 8, x.num_elements)
    x.processing_time != zero(Int64) && PB.encode(e, 9, x.processing_time)
    x.record_metrics != false && PB.encode(e, 10, x.record_metrics)
    !isempty(x.parameters) && PB.encode(e, 11, x.parameters)
    x.input_processing_time_sum != zero(Float64) && PB.encode(e, 12, x.input_processing_time_sum)
    x.input_processing_time_count != zero(Int64) && PB.encode(e, 13, x.input_processing_time_count)
    !isempty(x.inputs) && PB.encode(e, 14, x.inputs)
    x.node_class != NodeClass.UNKNOWN && PB.encode(e, 15, x.node_class)
    x.ratio != zero(Float64) && PB.encode(e, 16, x.ratio)
    x.memory_ratio != zero(Float64) && PB.encode(e, 17, x.memory_ratio)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelProto.Node")
    encoded_size = 0
    x.id != zero(Int64) && (encoded_size += PB._encoded_size(x.id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    x.autotune != false && (encoded_size += PB._encoded_size(x.autotune, 3))
    x.buffered_bytes != zero(Int64) && (encoded_size += PB._encoded_size(x.buffered_bytes, 4))
    x.buffered_elements != zero(Int64) && (encoded_size += PB._encoded_size(x.buffered_elements, 5))
    x.bytes_consumed != zero(Int64) && (encoded_size += PB._encoded_size(x.bytes_consumed, 6))
    x.bytes_produced != zero(Int64) && (encoded_size += PB._encoded_size(x.bytes_produced, 7))
    x.num_elements != zero(Int64) && (encoded_size += PB._encoded_size(x.num_elements, 8))
    x.processing_time != zero(Int64) && (encoded_size += PB._encoded_size(x.processing_time, 9))
    x.record_metrics != false && (encoded_size += PB._encoded_size(x.record_metrics, 10))
    !isempty(x.parameters) && (encoded_size += PB._encoded_size(x.parameters, 11))
    x.input_processing_time_sum != zero(Float64) && (encoded_size += PB._encoded_size(x.input_processing_time_sum, 12))
    x.input_processing_time_count != zero(Int64) && (encoded_size += PB._encoded_size(x.input_processing_time_count, 13))
    !isempty(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 14))
    x.node_class != NodeClass.UNKNOWN && (encoded_size += PB._encoded_size(x.node_class, 15))
    x.ratio != zero(Float64) && (encoded_size += PB._encoded_size(x.ratio, 16))
    x.memory_ratio != zero(Float64) && (encoded_size += PB._encoded_size(x.memory_ratio, 17))
    return encoded_size
end

struct var"ModelProto.OptimizationParams"
    algorithm::AutotuneAlgorithm.T
    cpu_budget::Int64
    ram_budget::Int64
    model_input_time::Float64
end
PB.default_values(::Type{var"ModelProto.OptimizationParams"}) = (;algorithm = AutotuneAlgorithm.DEFAULT, cpu_budget = zero(Int64), ram_budget = zero(Int64), model_input_time = zero(Float64))
PB.field_numbers(::Type{var"ModelProto.OptimizationParams"}) = (;algorithm = 1, cpu_budget = 2, ram_budget = 3, model_input_time = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ModelProto.OptimizationParams"})
    algorithm = AutotuneAlgorithm.DEFAULT
    cpu_budget = zero(Int64)
    ram_budget = zero(Int64)
    model_input_time = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            algorithm = PB.decode(d, AutotuneAlgorithm.T)
        elseif field_number == 2
            cpu_budget = PB.decode(d, Int64)
        elseif field_number == 3
            ram_budget = PB.decode(d, Int64)
        elseif field_number == 4
            model_input_time = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ModelProto.OptimizationParams"(algorithm, cpu_budget, ram_budget, model_input_time)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ModelProto.OptimizationParams")
    initpos = position(e.io)
    x.algorithm != AutotuneAlgorithm.DEFAULT && PB.encode(e, 1, x.algorithm)
    x.cpu_budget != zero(Int64) && PB.encode(e, 2, x.cpu_budget)
    x.ram_budget != zero(Int64) && PB.encode(e, 3, x.ram_budget)
    x.model_input_time != zero(Float64) && PB.encode(e, 4, x.model_input_time)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ModelProto.OptimizationParams")
    encoded_size = 0
    x.algorithm != AutotuneAlgorithm.DEFAULT && (encoded_size += PB._encoded_size(x.algorithm, 1))
    x.cpu_budget != zero(Int64) && (encoded_size += PB._encoded_size(x.cpu_budget, 2))
    x.ram_budget != zero(Int64) && (encoded_size += PB._encoded_size(x.ram_budget, 3))
    x.model_input_time != zero(Float64) && (encoded_size += PB._encoded_size(x.model_input_time, 4))
    return encoded_size
end

struct ModelProto
    nodes::Dict{Int64,var"ModelProto.Node"}
    output::Int64
    id_counter::Int64
    optimization_params::Union{Nothing,var"ModelProto.OptimizationParams"}
    gap_times::Vector{UInt64}
end
PB.reserved_fields(::Type{ModelProto}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4])
PB.default_values(::Type{ModelProto}) = (;nodes = Dict{Int64,var"ModelProto.Node"}(), output = zero(Int64), id_counter = zero(Int64), optimization_params = nothing, gap_times = Vector{UInt64}())
PB.field_numbers(::Type{ModelProto}) = (;nodes = 1, output = 2, id_counter = 3, optimization_params = 5, gap_times = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelProto})
    nodes = Dict{Int64,var"ModelProto.Node"}()
    output = zero(Int64)
    id_counter = zero(Int64)
    optimization_params = Ref{Union{Nothing,var"ModelProto.OptimizationParams"}}(nothing)
    gap_times = PB.BufferedVector{UInt64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, nodes)
        elseif field_number == 2
            output = PB.decode(d, Int64)
        elseif field_number == 3
            id_counter = PB.decode(d, Int64)
        elseif field_number == 5
            PB.decode!(d, optimization_params)
        elseif field_number == 6
            PB.decode!(d, wire_type, gap_times)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelProto(nodes, output, id_counter, optimization_params[], gap_times[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelProto)
    initpos = position(e.io)
    !isempty(x.nodes) && PB.encode(e, 1, x.nodes)
    x.output != zero(Int64) && PB.encode(e, 2, x.output)
    x.id_counter != zero(Int64) && PB.encode(e, 3, x.id_counter)
    !isnothing(x.optimization_params) && PB.encode(e, 5, x.optimization_params)
    !isempty(x.gap_times) && PB.encode(e, 6, x.gap_times)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelProto)
    encoded_size = 0
    !isempty(x.nodes) && (encoded_size += PB._encoded_size(x.nodes, 1))
    x.output != zero(Int64) && (encoded_size += PB._encoded_size(x.output, 2))
    x.id_counter != zero(Int64) && (encoded_size += PB._encoded_size(x.id_counter, 3))
    !isnothing(x.optimization_params) && (encoded_size += PB._encoded_size(x.optimization_params, 5))
    !isempty(x.gap_times) && (encoded_size += PB._encoded_size(x.gap_times, 6))
    return encoded_size
end
