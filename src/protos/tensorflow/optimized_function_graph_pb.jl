# Autogenerated using ProtoBuf.jl v1.0.15 on 2024-03-03T12:31:44.059

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"OptimizedFunctionGraph.OptimizationSource", OptimizedFunctionGraph

@enumx var"OptimizedFunctionGraph.OptimizationSource" SOURCE_UNSPECIFIED=0 AOT=1 JIT=2

struct OptimizedFunctionGraph
    name::String
    function_graph::Union{Nothing,GraphDef}
    node_name_to_control_ret::Dict{String,String}
    ret_types::Vector{var"#DataType".T}
    num_return_nodes::UInt32
    source::var"OptimizedFunctionGraph.OptimizationSource".T
    optimization_time_usecs::UInt64
end
PB.reserved_fields(::Type{OptimizedFunctionGraph}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[6])
PB.default_values(::Type{OptimizedFunctionGraph}) = (;name = "", function_graph = nothing, node_name_to_control_ret = Dict{String,String}(), ret_types = Vector{var"#DataType".T}(), num_return_nodes = zero(UInt32), source = var"OptimizedFunctionGraph.OptimizationSource".SOURCE_UNSPECIFIED, optimization_time_usecs = zero(UInt64))
PB.field_numbers(::Type{OptimizedFunctionGraph}) = (;name = 1, function_graph = 2, node_name_to_control_ret = 3, ret_types = 4, num_return_nodes = 5, source = 7, optimization_time_usecs = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OptimizedFunctionGraph})
    name = ""
    function_graph = Ref{Union{Nothing,GraphDef}}(nothing)
    node_name_to_control_ret = Dict{String,String}()
    ret_types = PB.BufferedVector{var"#DataType".T}()
    num_return_nodes = zero(UInt32)
    source = var"OptimizedFunctionGraph.OptimizationSource".SOURCE_UNSPECIFIED
    optimization_time_usecs = zero(UInt64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, function_graph)
        elseif field_number == 3
            PB.decode!(d, node_name_to_control_ret)
        elseif field_number == 4
            PB.decode!(d, wire_type, ret_types)
        elseif field_number == 5
            num_return_nodes = PB.decode(d, UInt32)
        elseif field_number == 7
            source = PB.decode(d, var"OptimizedFunctionGraph.OptimizationSource".T)
        elseif field_number == 8
            optimization_time_usecs = PB.decode(d, UInt64)
        else
            PB.skip(d, wire_type)
        end
    end
    return OptimizedFunctionGraph(name, function_graph[], node_name_to_control_ret, ret_types[], num_return_nodes, source, optimization_time_usecs)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OptimizedFunctionGraph)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.function_graph) && PB.encode(e, 2, x.function_graph)
    !isempty(x.node_name_to_control_ret) && PB.encode(e, 3, x.node_name_to_control_ret)
    !isempty(x.ret_types) && PB.encode(e, 4, x.ret_types)
    x.num_return_nodes != zero(UInt32) && PB.encode(e, 5, x.num_return_nodes)
    x.source != var"OptimizedFunctionGraph.OptimizationSource".SOURCE_UNSPECIFIED && PB.encode(e, 7, x.source)
    x.optimization_time_usecs != zero(UInt64) && PB.encode(e, 8, x.optimization_time_usecs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OptimizedFunctionGraph)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.function_graph) && (encoded_size += PB._encoded_size(x.function_graph, 2))
    !isempty(x.node_name_to_control_ret) && (encoded_size += PB._encoded_size(x.node_name_to_control_ret, 3))
    !isempty(x.ret_types) && (encoded_size += PB._encoded_size(x.ret_types, 4))
    x.num_return_nodes != zero(UInt32) && (encoded_size += PB._encoded_size(x.num_return_nodes, 5))
    x.source != var"OptimizedFunctionGraph.OptimizationSource".SOURCE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.source, 7))
    x.optimization_time_usecs != zero(UInt64) && (encoded_size += PB._encoded_size(x.optimization_time_usecs, 8))
    return encoded_size
end
